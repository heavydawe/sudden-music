  // useEffect(() => {
  //   if (props.curNoteToModify === null) {
  //     //&& props.curMidiClipToModify
  //     return;
  //   }

  //   // TODO: update curEvents here maybe?
  //   if (props.curNoteToModify !== null) {
  //     console.log("IN USEFFECT CURNOTE");
  //     dispatch(clearModifyNote());
  //     // updateCurEvents(
  //     //   props.curNoteToModify,
  //     //   props.midiClips,
  //     //   curInstrument!,
  //     //   curEvents,
  //     //   setCurEvents
  //     // );
  //   }
  // }, [
  //   props.curNoteToModify,
  //   props.midiClips,
  //   curInstrument,
  //   curEvents,
  //   dispatch,
  // ]);

  // useEffect(() => {
  //   if (curInstrument === undefined) {
  //     return;
  //   }

  //   if (!props.midiClips.length) {
  //     return;
  //   }

  //   if (!props.midiClips[0].notes.length) {
  //     return;
  //   }

  //   // TODO: optimize this with modify props
  //   //Tone.Transport.cancel(0);

  //   // const chord1 = ["D3", "G3"];
  //   // const chord2 = ["F3", "Bb3"];

  //   // TODO: delete this, and make sure every instr works
  //   if (!(curInstrument instanceof Tone.PolySynth)) {
  //     return;
  //   }

  //   // TODO: use modify props to add/remove notes, or add/remove parts.
  //   // A part should represent a midiclip, and all the notes inside it should be grouped together
  //   // using the values parameter for the callback function... LETS GO!
  //   // const newPart = new Tone.Part(
  //   //   (time, value) => {
  //   //     // the notes given as the second element in the array
  //   //     // will be passed in as the second argument
  //   //     curInstrument.triggerAttackRelease(value.note, value.length, time);
  //   //   },
  //   //   [
  //   //     { time: 0, note: chord1, velocity: 0.9, length: "8n" },
  //   //     { time: "0:2", note: chord2, velocity: 0.5, length: "4n" },
  //   //   ]
  //   // ).start(0);

  //   const newPart = new Tone.Part((time, value) => {
  //     curInstrument.triggerAttackRelease(value.note, value.length, time);
  //     console.log("in callback");
  //   }).start(`${props.midiClips[0].startTime}i`);

  //   const firstNote = {
  //     note: props.midiClips[0].notes[0].note,
  //     time: `${props.midiClips[0].notes[0].startTime}i`,
  //     length: `${props.midiClips[0].notes[0].length}i`,
  //   };

  //   // FONTOS: same objectnek kell lennie, hogy a törlés működjön megfelelően. Használni KELL a modify
  //   // interfaceket, ahhoz hogy ez megfelelően működjön
  //   // na most jó kérdés, hogy ha stateben elmentem és úgy adom hozzá mi lesz, vagy ha magát a store értéket
  //   // adom neki mi lesz. Ki kéne próbálni. TODO!

  //   newPart.add(firstNote);

  //   // newPart.remove({
  //   //   note: props.midiClips[0].notes[0].note,
  //   //   time: `${props.midiClips[0].notes[0].startTime}i`,
  //   //   length: `${props.midiClips[0].notes[0].length}i`,
  //   // });

  //   // ez így működik
  //   newPart.remove(firstNote);

  //   newPart.add({
  //     note: props.midiClips[0].notes[0].note,
  //     time: `${props.midiClips[0].notes[0].startTime + 768}i`,
  //     length: `${props.midiClips[0].notes[0].length * 2}i`,
  //   });

  //   // props.midiClips.forEach((midiClip) => {
  //   //   midiClip.notes.forEach((note) => {
  //   //     // setCurEvents((prevState) => [
  //   //     //   ...prevState,
  //   //     //   Tone.Transport.schedule(() => {
  //   //     //     curInstrument.triggerAttackRelease(
  //   //     //       note.note,
  //   //     //       `${note.length}i`,
  //   //     //       `+${note.startTime}i`
  //   //     //     );
  //   //     //   }, `${midiClip.startTime}i`),
  //   //     // ]);
  //   //   });
  //   // });
  // }, [props.midiClips, curInstrument]);

  // if (curInstrument !== undefined && props.midiClips[0] !== undefined) {
  //   const tempArr = props.midiClips[0].notes.map((note) => {
  //     return {
  //       note: note.note,
  //       duration: `${note.length}i`,
  //       startTime: 000`+${note.startTime}i`,
  //     };
  //   });

  //   if (Tone.Transport.state === "started") {
  //     Tone.Transport.stop();
  //   }

  //   Tone.Transport.cancel(0);
  //   Tone.Transport.scheduleRepeat(() => {
  //     tempArr.forEach((item) => {
  //       const eventID = curInstrument.triggerAttackRelease(
  //         item.note,
  //         item.duration,
  //         item.startTime
  //       );
  //       console.log(eventID);
  //     });
  //   }, "1m");

  //   Tone.Transport.start();
  // }